package org.sasanlabs.service.vulnerability.pathTraversal;

import static org.sasanlabs.vulnerability.utils.Constants.NULL_BYTE_CHARACTER;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.http.HttpStatus;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestParam;

/**
 * Path traversal vulnerability. <a
 * href="https://en.wikipedia.org/wiki/Directory_traversal_attack">More information</a>
 *
 * @author KSASAN preetkaran20@gmail.com
 */
@VulnerableAppRestController(
        descriptionLabel = "PATH_TRAVERSAL_VULNERABILITY",
        value = "PathTraversal")
public class PathTraversalVulnerability {

    private static final List<String> ALLOWED_FILE_NAMES =
            Arrays.asList("UserInfo.json", "OwaspAppInfo.json");

    private static final transient Logger LOGGER =
            LogManager.getLogger(PathTraversalVulnerability.class);

    private static final String URL_PARAM_KEY = "fileName";

    private ResponseEntity<GenericVulnerabilityResponseBean<String>> readFile(
            Supplier<Boolean> condition, String fileName) {
        if (condition.get()) {
            try {
                File infoFile =
                        new File(
                                this.getClass().getResource("/").toURI().getPath()
                                        + "scripts/PathTraversal/"
                                        + fileName);
                FileInputStream infoFileStream;
                infoFileStream = new FileInputStream(infoFile);
                if (infoFileStream != null) {
                    try (BufferedReader reader =
                            new BufferedReader(new InputStreamReader(infoFileStream))) {
                        String information = reader.readLine();
                        StringBuilder payload = new StringBuilder();
                        while (information != null) {
                            payload.append(information);
                            information = reader.readLine();
                        }
                        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                                new GenericVulnerabilityResponseBean<>(payload.toString(), true),
                                HttpStatus.OK);
                    } catch (IOException e) {
                        LOGGER.error("Following error occurred: ", e);
                    }
                }
            } catch (FileNotFoundException | URISyntaxException ex) {
                LOGGER.error("Following error occurred: ", ex);
            }
        }
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<>(), HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PATH_TRAVERSAL},
            description = "PATH_TRAVERSAL_URL_PARAM_DIRECTLY_INJECTED")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            htmlTemplate = "LEVEL_1/PathTraversal")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(
            @RequestParam Map<String, String> queryParams) {
        String fileName = queryParams.get(URL_PARAM_KEY);
        return this.readFile(() -> fileName != null, fileName);
    }

    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PATH_TRAVERSAL},
            description = "PATH_TRAVERSAL_URL_PARAM_DIRECTLY_INJECTED")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_2,
            htmlTemplate = "LEVEL_1/PathTraversal")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(
            RequestEntity<String> requestEntity, @RequestParam Map<String, String> queryParams) {
        String fileName = queryParams.get(URL_PARAM_KEY);
        return this.readFile(
                () -> !requestEntity.getUrl().toString().contains("../") && fileName != null,
                fileName);
    }

    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PATH_TRAVERSAL},
            description = "PATH_TRAVERSAL_URL_PARAM_IF_DOT_DOT_PATH_NOT_PRESENT_DIRECTLY_INJECTED")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_3,
            htmlTemplate = "LEVEL_1/PathTraversal")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel3(
            RequestEntity<String> requestEntity, @RequestParam Map<String, String> queryParams) {
        String fileName = queryParams.get(URL_PARAM_KEY);
        return this.readFile(
                () -> !requestEntity.getUrl().toString().contains("..") && fileName != null,
                fileName);
    }

    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PATH_TRAVERSAL},
            description =
                    "PATH_TRAVERSAL_URL_PARAM_IF_DOT_DOT_PATH_OR_%2F_NOT_PRESENT_DIRECTLY_INJECTED")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_4,
            htmlTemplate = "LEVEL_1/PathTraversal")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel4(
            RequestEntity<String> requestEntity, @RequestParam Map<String, String> queryParams) {
        String fileName = queryParams.get(URL_PARAM_KEY);
        return this.readFile(
                () ->
                        !requestEntity.getUrl().toString().contains("..")
                                && !requestEntity.getUrl().toString().contains("%2f")
                                && fileName != null,
                fileName);
    }

    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PATH_TRAVERSAL},
            description =
                    "PATH_TRAVERSAL_URL_PARAM_IF_DOT_DOT_PATH_OR_%2F_CASE_INSENSITIVE_NOT_PRESENT_DIRECTLY_INJECTED")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_5,
            htmlTemplate = "LEVEL_1/PathTraversal")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel5(
            RequestEntity<String> requestEntity, @RequestParam Map<String, String> queryParams) {
        String fileName = queryParams.get(URL_PARAM_KEY);
        return this.readFile(
                () ->
                        !requestEntity.getUrl().toString().contains("..")
                                && !requestEntity.getUrl().toString().toLowerCase().contains("%2f")
                                && fileName != null,
                fileName);
    }

    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PATH_TRAVERSAL},
            description =
                    "PATH_TRAVERSAL_URL_PARAM_IF_DOT_DOT_PATH_WITH_OR_WITHOUT_URL_ENCODING_NOT_PRESENT_DIRECTLY_INJECTED")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_6,
            htmlTemplate = "LEVEL_1/PathTraversal")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel6(
            @RequestParam Map<String, String> queryParams) {
        String fileName = queryParams.get(URL_PARAM_KEY);
        return this.readFile(() -> fileName != null && !fileName.contains(".."), fileName);
    }

    // Null Byte
    // http://192.168.0.148:9090/vulnerable/PathTraversal/LEVEL_7?fileName=../../../../../../../../../../../../etc/passwd%00UserInfo.json
    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PATH_TRAVERSAL},
            description = "PATH_TRAVERSAL_URL_PARAM_BEFORE_NULL_BYTE_DIRECTLY_INJECTED")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_7,
            htmlTemplate = "LEVEL_1/PathTraversal")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel7(
            RequestEntity<String> requestEntity, @RequestParam Map<String, String> queryParams) {
        String queryFileName = queryParams.get(URL_PARAM_KEY);
        String fileName = null;
        if (queryFileName != null) {
            int indexOfNullByte = queryFileName.indexOf(NULL_BYTE_CHARACTER);
            fileName =
                    indexOfNullByte >= 0
                            ? queryFileName.substring(0, indexOfNullByte)
                            : queryFileName;
        }
        return this.readFile(
                () ->
                        queryFileName != null
                                && ALLOWED_FILE_NAMES.stream()
                                        .anyMatch(
                                                allowedFileName ->
                                                        queryFileName.contains(allowedFileName)),
                fileName);
    }

    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PATH_TRAVERSAL},
            description =
                    "PATH_TRAVERSAL_URL_PARAM_BEFORE_NULL_BYTE_IF_PARENT_DIRECTORY_PATH_NOT_PRESENT_DIRECTLY_INJECTED")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_8,
            htmlTemplate = "LEVEL_1/PathTraversal")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel8(
            RequestEntity<String> requestEntity, @RequestParam Map<String, String> queryParams) {
        String queryFileName = queryParams.get(URL_PARAM_KEY);
        String fileName = null;
        if (queryFileName != null) {
            int indexOfNullByte = queryFileName.indexOf(NULL_BYTE_CHARACTER);
            fileName =
                    indexOfNullByte >= 0
                            ? queryFileName.substring(0, indexOfNullByte)
                            : queryFileName;
        }
        return this.readFile(
                () ->
                        queryFileName != null
                                && !requestEntity.getUrl().toString().contains("../")
                                && ALLOWED_FILE_NAMES.stream()
                                        .anyMatch(
                                                allowedFileName ->
                                                        queryFileName.contains(allowedFileName)),
                fileName);
    }

    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PATH_TRAVERSAL},
            description =
                    "PATH_TRAVERSAL_URL_PARAM_BEFORE_NULL_BYTE_IF_DOT_DOT_PATH_NOT_PRESENT_DIRECTLY_INJECTED")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_9,
            htmlTemplate = "LEVEL_1/PathTraversal")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel9(
            RequestEntity<String> requestEntity, @RequestParam Map<String, String> queryParams) {
        String queryFileName = queryParams.get(URL_PARAM_KEY);
        String fileName = null;
        if (queryFileName != null) {
            int indexOfNullByte = queryFileName.indexOf(NULL_BYTE_CHARACTER);
            fileName =
                    indexOfNullByte >= 0
                            ? queryFileName.substring(0, indexOfNullByte)
                            : queryFileName;
        }
        return this.readFile(
                () ->
                        queryFileName != null
                                && !requestEntity.getUrl().toString().contains("..")
                                && ALLOWED_FILE_NAMES.stream()
                                        .anyMatch(
                                                allowedFileName ->
                                                        queryFileName.contains(allowedFileName)),
                fileName);
    }

    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PATH_TRAVERSAL},
            description =
                    "PATH_TRAVERSAL_URL_PARAM_BEFORE_NULL_BYTE_IF_DOT_DOT_PATH_OR_%2F_NOT_PRESENT_DIRECTLY_INJECTED")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_10,
            htmlTemplate = "LEVEL_1/PathTraversal")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel10(
            RequestEntity<String> requestEntity, @RequestParam Map<String, String> queryParams) {
        String queryFileName = queryParams.get(URL_PARAM_KEY);
        String fileName = null;
        if (queryFileName != null) {
            int indexOfNullByte = queryFileName.indexOf(NULL_BYTE_CHARACTER);
            fileName =
                    indexOfNullByte >= 0
                            ? queryFileName.substring(0, indexOfNullByte)
                            : queryFileName;
        }
        return this.readFile(
                () ->
                        queryFileName != null
                                && !requestEntity.getUrl().toString().contains("..")
                                && !requestEntity.getUrl().toString().contains("%2f")
                                && ALLOWED_FILE_NAMES.stream()
                                        .anyMatch(
                                                allowedFileName ->
                                                        queryFileName.contains(allowedFileName)),
                fileName);
    }

    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PATH_TRAVERSAL},
            description =
                    "PATH_TRAVERSAL_URL_PARAM_BEFORE_NULL_BYTE_IF_DOT_DOT_PATH_OR_%2F_CASE_INSENSITIVE_NOT_PRESENT_DIRECTLY_INJECTED")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_11,
            htmlTemplate = "LEVEL_1/PathTraversal")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel11(
            RequestEntity<String> requestEntity, @RequestParam Map<String, String> queryParams) {
        String queryFileName = queryParams.get(URL_PARAM_KEY);
        String fileName = null;
        if (queryFileName != null) {
            int indexOfNullByte = queryFileName.indexOf(NULL_BYTE_CHARACTER);
            fileName =
                    indexOfNullByte >= 0
                            ? queryFileName.substring(0, indexOfNullByte)
                            : queryFileName;
        }
        return this.readFile(
                () ->
                        queryFileName != null
                                && !requestEntity.getUrl().toString().contains("..")
                                && !requestEntity.getUrl().toString().toLowerCase().contains("%2f")
                                && ALLOWED_FILE_NAMES.stream()
                                        .anyMatch(
                                                allowedFileName ->
                                                        queryFileName.contains(allowedFileName)),
                fileName);
    }

    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PATH_TRAVERSAL},
            description =
                    "PATH_TRAVERSAL_URL_PARAM_BEFORE_NULL_BYTE_IF_DOT_DOT_PATH_WITH_OR_WITHOUT_URL_ENCODING_NOT_PRESENT_DIRECTLY_INJECTED")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_12,
            htmlTemplate = "LEVEL_1/PathTraversal")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel12(
            @RequestParam Map<String, String> queryParams) {
        String queryFileName = queryParams.get(URL_PARAM_KEY);
        String fileName = null;
        if (queryFileName != null) {
            int indexOfNullByte = queryFileName.indexOf(NULL_BYTE_CHARACTER);
            fileName =
                    indexOfNullByte >= 0
                            ? queryFileName.substring(0, indexOfNullByte)
                            : queryFileName;
        }
        return this.readFile(
                () ->
                        queryFileName != null
                                && !queryFileName.contains("..")
                                && ALLOWED_FILE_NAMES.stream()
                                        .anyMatch(
                                                allowedFileName ->
                                                        queryFileName.contains(allowedFileName)),
                fileName);
    }
}
