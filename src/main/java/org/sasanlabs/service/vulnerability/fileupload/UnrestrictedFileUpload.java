package org.sasanlabs.service.vulnerability.fileupload;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.FileSystemException;
import java.nio.file.FileSystemNotFoundException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Date;
import java.util.Random;
import java.util.function.Supplier;
import java.util.regex.Pattern;
import org.apache.commons.text.StringEscapeUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.sasanlabs.internal.utility.FrameworkConstants;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.Variant;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.service.exception.ServiceApplicationException;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.sasanlabs.vulnerability.utils.Constants;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

/**
 * @author KSASAN preetkaran20@gmail.com
 *     <p>Special Thanks
 *     <p>https://bezkoder.com/spring-boot-file-upload/
 *     <p>https://developer.mozilla.org/en-US/docs/Web/API/FormData/Using_FormData_Objects
 *     <p>https://www.youtube.com/watch?v=CmF9sEyKZNo
 */
@VulnerableAppRestController(
        descriptionLabel = "UNRESTRICTED_FILE_UPLOAD_VULNERABILITY",
        value = "UnrestrictedFileUpload")
public class UnrestrictedFileUpload {
    private Path root;
    private Path contentDispositionRoot;

    private static final String STATIC_FILE_LOCATION = "upload";
    static final String CONTENT_DISPOSITION_STATIC_FILE_LOCATION = "contentDispositionUpload";
    private static final String BASE_PATH = "static";
    private static final String REQUEST_PARAMETER = "file";
    private static final Random RANDOM = new Random(new Date().getTime());
    private static final Pattern ENDS_WITH_HTML_PATTERN = Pattern.compile("^.+\\.html$");
    private static final Pattern ENDS_WITH_HTML_OR_HTM_PATTERN =
            Pattern.compile("^.+\\.(html|htm)$");

    private static final String CONTAINS_PNG_JPEG_REGEX = "^.+\\.(png|jpeg)";
    private static final Pattern CONTAINS_PNG_OR_JPEG_PATTERN =
            Pattern.compile(CONTAINS_PNG_JPEG_REGEX);
    private static final Pattern ENDS_WITH_PNG_OR_JPEG_PATTERN =
            Pattern.compile(CONTAINS_PNG_JPEG_REGEX + "$");
    private static final transient Logger LOGGER =
            LogManager.getLogger(UnrestrictedFileUpload.class);

    public UnrestrictedFileUpload() throws IOException, URISyntaxException {
        URI uploadDirectoryURI;
        try {
            uploadDirectoryURI =
                    new URI(
                            Thread.currentThread()
                                            .getContextClassLoader()
                                            .getResource(BASE_PATH)
                                            .toURI()
                                    + FrameworkConstants.SLASH
                                    + STATIC_FILE_LOCATION);
            root = Paths.get(uploadDirectoryURI);
            if (!root.toFile().exists()) {
                Files.createDirectory(root);
            }
            contentDispositionRoot =
                    Paths.get(
                            FrameworkConstants.SLASH
                                    + CONTENT_DISPOSITION_STATIC_FILE_LOCATION
                                    + FrameworkConstants.SLASH);
            if (!contentDispositionRoot.toFile().exists()) {
                Files.createDirectory(contentDispositionRoot);
            }
        } catch (FileSystemNotFoundException | FileSystemException e) {
            // Temporary Fix, FileUpload is not working in jar.
            LOGGER.error(
                    "If you are running vulnerableApp as a Jar then UnrestrictedFileUpload will not work. "
                            + "For more information: https://github.com/SasanLabs/VulnerableApp/issues/255",
                    e);
            if (root != null) {
                root = Files.createTempDirectory(null);
            }
            if (contentDispositionRoot != null) {
                contentDispositionRoot = Files.createTempDirectory(null);
            }
        }
    }

    private static final ResponseEntity<GenericVulnerabilityResponseBean<String>>
            genericFileUploadUtility(
                    Path root,
                    String fileName,
                    Supplier<Boolean> validator,
                    MultipartFile file,
                    boolean htmlEncode,
                    boolean isContentDisposition)
                    throws IOException {
        if (validator.get()) {
            Files.copy(
                    file.getInputStream(),
                    root.resolve(fileName),
                    StandardCopyOption.REPLACE_EXISTING);
            String uploadedFileLocation;
            if (htmlEncode) {
                uploadedFileLocation =
                        StringEscapeUtils.escapeHtml4(
                                FrameworkConstants.VULNERABLE_APP
                                        + FrameworkConstants.SLASH
                                        + (isContentDisposition
                                                ? CONTENT_DISPOSITION_STATIC_FILE_LOCATION
                                                : STATIC_FILE_LOCATION)
                                        + FrameworkConstants.SLASH
                                        + fileName);
            } else {
                uploadedFileLocation =
                        FrameworkConstants.VULNERABLE_APP
                                + FrameworkConstants.SLASH
                                + (isContentDisposition
                                        ? CONTENT_DISPOSITION_STATIC_FILE_LOCATION
                                        : STATIC_FILE_LOCATION)
                                + FrameworkConstants.SLASH
                                + fileName;
            }
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(uploadedFileLocation, true),
                    HttpStatus.OK);
        }
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>("Input is invalid", false),
                HttpStatus.OK);
    }

    Path getContentDispositionRoot() {
        return contentDispositionRoot;
    }

    // <img src="" onerror=alert(1) /> file name reflected and stored is there.
    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilityType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilityType.PERSISTENT_XSS,
                VulnerabilityType.REFLECTED_XSS,
                VulnerabilityType.PATH_TRAVERSAL
            },
            description = "UNRESTRICTED_FILE_UPLOAD_NO_VALIDATION_FILE_NAME",
            payload = "UNRESTRICTED_FILE_UPLOAD_PAYLOAD_LEVEL_1")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            htmlTemplate = "LEVEL_1/FileUpload",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(
            @RequestParam(REQUEST_PARAMETER) MultipartFile file)
            throws ServiceApplicationException, IOException, URISyntaxException {
        return genericFileUploadUtility(
                root, file.getOriginalFilename(), () -> true, file, false, false);
    }

    // <img src="" onerror=alert(1) /> file name reflected and stored is there.
    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilityType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilityType.PERSISTENT_XSS,
                VulnerabilityType.REFLECTED_XSS
            },
            description = "UNRESTRICTED_FILE_UPLOAD_NO_VALIDATION_FILE_NAME",
            payload = "UNRESTRICTED_FILE_UPLOAD_PAYLOAD_LEVEL_2")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_2,
            htmlTemplate = "LEVEL_1/FileUpload",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(
            @RequestParam(REQUEST_PARAMETER) MultipartFile file)
            throws ServiceApplicationException, IOException {
        String fileName = RANDOM.nextInt() + "_" + file.getOriginalFilename();
        return genericFileUploadUtility(root, fileName, () -> true, file, false, false);
    }

    // .htm extension breaks the file upload vulnerability
    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilityType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilityType.PERSISTENT_XSS,
                VulnerabilityType.REFLECTED_XSS
            },
            description = "UNRESTRICTED_FILE_UPLOAD_IF_NOT_HTML_FILE_EXTENSION",
            payload = "UNRESTRICTED_FILE_UPLOAD_PAYLOAD_LEVEL_3")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_3,
            htmlTemplate = "LEVEL_1/FileUpload",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel3(
            @RequestParam(REQUEST_PARAMETER) MultipartFile file)
            throws ServiceApplicationException, IOException {
        Supplier<Boolean> validator =
                () -> !ENDS_WITH_HTML_PATTERN.matcher(file.getOriginalFilename()).matches();
        return genericFileUploadUtility(
                root,
                RANDOM.nextInt() + "_" + file.getOriginalFilename(),
                validator,
                file,
                false,
                false);
    }

    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilityType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilityType.PERSISTENT_XSS,
                VulnerabilityType.REFLECTED_XSS
            },
            description = "UNRESTRICTED_FILE_UPLOAD_IF_NOT_HTML_NOT_HTM_FILE_EXTENSION",
            payload = "UNRESTRICTED_FILE_UPLOAD_PAYLOAD_LEVEL_4")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_4,
            htmlTemplate = "LEVEL_1/FileUpload",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel4(
            @RequestParam(REQUEST_PARAMETER) MultipartFile file)
            throws ServiceApplicationException, IOException {
        Supplier<Boolean> validator =
                () -> !ENDS_WITH_HTML_OR_HTM_PATTERN.matcher(file.getOriginalFilename()).matches();
        return genericFileUploadUtility(
                root,
                RANDOM.nextInt() + "_" + file.getOriginalFilename(),
                validator,
                file,
                false,
                false);
    }

    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilityType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilityType.PERSISTENT_XSS,
                VulnerabilityType.REFLECTED_XSS
            },
            description =
                    "UNRESTRICTED_FILE_UPLOAD_IF_NOT_HTML_NOT_HTM_FILE_EXTENSION_CASE_INSENSITIVE",
            payload = "UNRESTRICTED_FILE_UPLOAD_PAYLOAD_LEVEL_5")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_5,
            htmlTemplate = "LEVEL_1/FileUpload",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel5(
            @RequestParam(REQUEST_PARAMETER) MultipartFile file)
            throws ServiceApplicationException, IOException {
        Supplier<Boolean> validator =
                () ->
                        !ENDS_WITH_HTML_OR_HTM_PATTERN
                                .matcher(file.getOriginalFilename().toLowerCase())
                                .matches();
        return genericFileUploadUtility(
                root,
                RANDOM.nextInt() + "_" + file.getOriginalFilename(),
                validator,
                file,
                false,
                false);
    }

    // WhiteList approach
    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilityType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilityType.PERSISTENT_XSS,
                VulnerabilityType.REFLECTED_XSS
            },
            description =
                    "UNRESTRICTED_FILE_UPLOAD_IF_FILE_NAME_NOT_CONTAINS_.PNG_OR_.JPEG_CASE_INSENSITIVE",
            payload = "UNRESTRICTED_FILE_UPLOAD_PAYLOAD_LEVEL_6")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_6,
            htmlTemplate = "LEVEL_1/FileUpload",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel6(
            @RequestParam(REQUEST_PARAMETER) MultipartFile file)
            throws ServiceApplicationException, IOException {

        Supplier<Boolean> validator =
                () -> CONTAINS_PNG_OR_JPEG_PATTERN.matcher(file.getOriginalFilename()).find();
        return genericFileUploadUtility(
                root,
                RANDOM.nextInt() + "_" + file.getOriginalFilename(),
                validator,
                file,
                false,
                false);
    }

    // Null Byte Attack
    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilityType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilityType.PERSISTENT_XSS,
                VulnerabilityType.REFLECTED_XSS
            },
            description =
                    "UNRESTRICTED_FILE_UPLOAD_IF_FILE_NAME_NOT_ENDS_WITH_.PNG_OR_.JPEG_CASE_INSENSITIVE_AND_FILE_NAMES_CONSIDERED_BEFORE_NULL_BYTE",
            payload = "UNRESTRICTED_FILE_UPLOAD_PAYLOAD_LEVEL_7")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_7,
            htmlTemplate = "LEVEL_1/FileUpload",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel7(
            @RequestParam(REQUEST_PARAMETER) MultipartFile file)
            throws ServiceApplicationException, IOException {
        String originalFileName;
        if (file.getOriginalFilename().contains(Constants.NULL_BYTE_CHARACTER)) {
            originalFileName =
                    file.getOriginalFilename()
                            .substring(
                                    0,
                                    file.getOriginalFilename()
                                            .indexOf(Constants.NULL_BYTE_CHARACTER));
        } else {
            originalFileName = file.getOriginalFilename();
        }
        Supplier<Boolean> validator =
                () -> ENDS_WITH_PNG_OR_JPEG_PATTERN.matcher(file.getOriginalFilename()).matches();
        return genericFileUploadUtility(
                root, RANDOM.nextInt() + "_" + originalFileName, validator, file, false, false);
    }

    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PATH_TRAVERSAL},
            description = "UNRESTRICTED_FILE_UPLOAD_NO_VALIDATION_FILE_NAME",
            payload = "UNRESTRICTED_FILE_UPLOAD_PAYLOAD_LEVEL_8")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_8,
            htmlTemplate = "LEVEL_1/FileUpload",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel9(
            @RequestParam(REQUEST_PARAMETER) MultipartFile file)
            throws ServiceApplicationException, IOException {
        return genericFileUploadUtility(
                contentDispositionRoot, file.getOriginalFilename(), () -> true, file, true, true);
    }

    // I think below vulnerability is not exploitable. Need to check again after running Owasp
    // ZAP FileUpload Addon.
    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilityType.UNRESTRICTED_FILE_UPLOAD,
                VulnerabilityType.PERSISTENT_XSS
            },
            description =
                    "UNRESTRICTED_FILE_UPLOAD_IF_FILE_NAME_NOT_ENDS_WITH_.PNG_OR_.JPEG_CASE_INSENSITIVE")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_9,
            variant = Variant.SECURE,
            htmlTemplate = "LEVEL_1/FileUpload",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel8(
            @RequestParam(REQUEST_PARAMETER) MultipartFile file)
            throws ServiceApplicationException, IOException {
        String fileName = file.getOriginalFilename();
        Supplier<Boolean> validator =
                () -> ENDS_WITH_PNG_OR_JPEG_PATTERN.matcher(fileName).matches();
        return genericFileUploadUtility(
                root,
                RANDOM.nextInt() + "_" + file.getOriginalFilename(),
                validator,
                file,
                true,
                false);
    }
}
