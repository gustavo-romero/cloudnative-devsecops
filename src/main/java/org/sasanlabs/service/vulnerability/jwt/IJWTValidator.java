package org.sasanlabs.service.vulnerability.jwt;

import java.io.UnsupportedEncodingException;
import java.security.Key;
import org.json.JSONException;
import org.sasanlabs.service.exception.ServiceApplicationException;

/**
 * JWTValidator is used for validating jwt token. it will contain various implementations of
 * validating libraries.
 *
 * @author KSASAN preetkaran20@gmail.com
 */
public interface IJWTValidator {
    /**
     * Custom HMAC based JWT validator. it is written using java jce implementation
     *
     * @param token
     * @param key
     * @param algorithm
     * @return
     * @throws ServiceApplicationException
     */
    boolean customHMACValidator(String token, byte[] key, String algorithm)
            throws ServiceApplicationException;

    /**
     * Null byte vulnerable HMAC based jwt validator. it uses {@link
     * IJWTValidator#customHMACValidator(String, byte[], String)} method internally but stops
     * reading signature after null byte to replicate the behavior of c/c++ string "\0" character
     *
     * @param token
     * @param key
     * @param algorithm
     * @return
     * @throws ServiceApplicationException
     */
    boolean customHMACNullByteVulnerableValidator(String token, byte[] key, String algorithm)
            throws ServiceApplicationException;

    /**
     * None algorithm vulnerable HMAC based jwt validator. it assumes if algorithm present in token
     * is None then token is already validated it uses {@link
     * IJWTValidator#customHMACValidator(String, byte[], String)} method
     *
     * @param token
     * @param key
     * @param algorithm
     * @return
     * @throws ServiceApplicationException
     */
    boolean customHMACNoneAlgorithmVulnerableValidator(String token, byte[] key, String algorithm)
            throws ServiceApplicationException;

    /**
     * Empty token vulnerable HMAC based jwt validator. it marks empty token as validated one. it
     * uses {@link IJWTValidator#customHMACValidator(String, byte[], String)} method
     *
     * @param token
     * @param key
     * @param algorithm
     * @return
     * @throws ServiceApplicationException
     */
    boolean customHMACEmptyTokenVulnerableValidator(String token, String key, String algorithm)
            throws ServiceApplicationException;

    /**
     * This validator is vulnerable to the Confusion Algorithm attack.
     *
     * <p>Background about the attack:<br>
     * Say an application is using RSA to sign JWT now what will be the verification method {@code
     * verify(String jwtToken, byte[] key); }
     *
     * <p>Now if application is using RSA then for verification RSA public key will be used and in
     * case jwttoken is based on HMAC algorithm then verify method will think key as Secret key for
     * HMAC and will try to decrypt it and as public key is known to everyone so anyone can sign the
     * key with public key and HMAC will accept it.
     *
     * @param token
     * @param key
     * @return
     * @throws ServiceApplicationException
     */
    boolean confusionAlgorithmVulnerableValidator(String token, Key key)
            throws ServiceApplicationException;

    /**
     * Considers Public Key present in JWK Header as trusted which is supplied by the user and
     * should not be trusted.
     *
     * @param token
     * @return
     * @throws UnsupportedEncodingException
     * @throws JSONException
     */
    boolean jwkKeyHeaderPublicKeyTrustingVulnerableValidator(String token)
            throws ServiceApplicationException;

    /**
     * Generic Method for validating the JWT token.
     *
     * @param token
     * @param key
     * @param algorithm
     * @return
     * @throws ServiceApplicationException
     */
    boolean genericJWTTokenValidator(String token, Key key, String algorithm)
            throws ServiceApplicationException;
}
