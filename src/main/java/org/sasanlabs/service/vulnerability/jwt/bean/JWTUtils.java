package org.sasanlabs.service.vulnerability.jwt.bean;

import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import org.apache.commons.io.IOUtils;
import org.sasanlabs.service.exception.ExceptionStatusCodeEnum;
import org.sasanlabs.service.exception.ServiceApplicationException;

/** @author KSASAN preetkaran20@gmail.com */
public class JWTUtils {

    public static final char JWT_TOKEN_PERIOD_CHARACTER = '.';

    public static final String JWT_TOKEN_PERIOD_CHARACTER_REGEX =
            "[" + JWT_TOKEN_PERIOD_CHARACTER + "]";

    public static final String BASE64_PADDING_CHARACTER_REGEX = "=";

    public static final String NONE_ALGORITHM = "none";
    public static final String JWT_ALGORITHM_KEY_HEADER = "alg";
    public static final String JSON_WEB_KEY_HEADER = "jwk";
    public static final String JWT_RSA_ALGORITHM_IDENTIFIER = "RS";
    public static final String JWT_RSA_PSS_ALGORITHM_IDENTIFIER = "PS";
    public static final String JWT_HMAC_ALGORITHM_IDENTIFIER = "HS";
    public static final String JWT_EC_ALGORITHM_IDENTIFIER = "EC";
    public static final String JWT_OCTET_ALGORITHM_IDENTIFIER = "ED";
    public static final String JWT_HMAC_SHA_256_ALGORITHM = "HS256";
    // TODO need to make it better.
    public static final String HS256_TOKEN_TO_BE_SIGNED =
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9."
                    + "eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ";

    public static final String RS256_TOKEN_TO_BE_SIGNED =
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9."
                    + "eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0";

    public static final String GENERIC_BASE64_ENCODED_PAYLOAD =
            "eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG"
                    + "4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0";

    public static final String KEYS_LOCATION = "static/templates/JWTVulnerability/keys/";

    /**
     * This is the Begining and Ending token of Public and Private Keys encoded with PKCS#8
     * encoding. In case you find PEM file not having these tokens and instead have -----BEGIN RSA
     * PRIVATE KEY----- or -----BEGIN RSA PUBLIC KEY----- then those are encoded by old format. To
     * Generate new Keys please use following <a
     * href="https://en.wikibooks.org/wiki/Cryptography/Generate_a_keypair_using_OpenSSL">link</a>
     */
    public static final String BEGIN_PRIVATE_KEY_TOKEN = "-----BEGIN PRIVATE KEY-----";

    public static final String END_PRIVATE_KEY_TOKEN = "-----END PRIVATE KEY-----";
    public static final String BEGIN_PUBLIC_KEY_TOKEN = "-----BEGIN PUBLIC KEY-----";
    public static final String END_PUBLIC_KEY_TOKEN = "-----END PUBLIC KEY-----";

    public static byte[] getBytes(String token) throws UnsupportedEncodingException {
        return token.getBytes(StandardCharsets.UTF_8);
    }

    public static String getString(byte[] tokenBytes) throws UnsupportedEncodingException {
        return new String(tokenBytes, StandardCharsets.UTF_8);
    }

    public static final Map<String, String> JWT_HMAC_ALGO_TO_JAVA_ALGORITHM_MAPPING =
            createJWTHmacAlgoToJavaAlgoMapping();

    static Map<String, String> createJWTHmacAlgoToJavaAlgoMapping() {
        Map<String, String> jwtAlgoToJavaAlgoMapping = new HashMap<String, String>();
        jwtAlgoToJavaAlgoMapping.put(JWT_HMAC_SHA_256_ALGORITHM, "HmacSHA256");
        jwtAlgoToJavaAlgoMapping.put("HS384", "HmacSHA384");
        jwtAlgoToJavaAlgoMapping.put("HS512", "HmacSHA512");
        return jwtAlgoToJavaAlgoMapping;
    }

    /**
     * we are using <a href="https://en.wikipedia.org/wiki/Base64#URL_applications">base64 Url Safe
     * encoding</a>. because of JWT specifications <br>
     * Also we are removing the padding as per <a
     * href="https://www.rfc-editor.org/rfc/rfc7515.txt">RFC 7515</a> padding is not there in JWT.
     *
     * @param token
     * @return
     * @throws UnsupportedEncodingException
     */
    public static String getBase64UrlSafeWithoutPaddingEncodedString(String token)
            throws UnsupportedEncodingException {
        return JWTUtils.getBase64UrlSafeWithoutPaddingEncodedString(getBytes(token));
    }

    /**
     * we are using <a href="https://en.wikipedia.org/wiki/Base64#URL_applications">base64 Url Safe
     * encoding</a>. because of JWT specifications <br>
     * Also we are removing the padding as per <a
     * href="https://www.rfc-editor.org/rfc/rfc7515.txt">RFC 7515</a> padding is not there in JWT.
     *
     * @param token
     * @return
     * @throws UnsupportedEncodingException
     */
    public static String getBase64UrlSafeWithoutPaddingEncodedString(byte[] token)
            throws UnsupportedEncodingException {
        return JWTUtils.getString(Base64.getUrlEncoder().encode(token))
                .replaceAll(BASE64_PADDING_CHARACTER_REGEX, "");
    }

    /**
     * Utility method for reading the PEM file and building RSAPrivateKey from it. Note: This method
     * assumes that PEM file contains PKCS#8 encoded Key format please check the format.
     *
     * @param pemFile InputStream of PEM file containing RSA Private Key
     * @return RSAPrivateKey by reading PEM file containing the RSA Private Key.
     * @throws JWTException if unable to read the provided file path or key specification is
     *     incorrect etc.
     */
    public static RSAPrivateKey getRSAPrivateKeyFromProvidedPEMFilePath(InputStream pemFile)
            throws ServiceApplicationException {
        try {
            String certAndKey = IOUtils.toString(pemFile, StandardCharsets.US_ASCII);
            byte[] keyBytes =
                    parseDERFromPEM(certAndKey, BEGIN_PRIVATE_KEY_TOKEN, END_PRIVATE_KEY_TOKEN);
            PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
            KeyFactory factory = KeyFactory.getInstance("RSA");
            return (RSAPrivateKey) factory.generatePrivate(spec);
        } catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException e) {
            throw new ServiceApplicationException(ExceptionStatusCodeEnum.SYSTEM_ERROR, e);
        }
    }

    /**
     * Utility method for reading the PEM file and building RSAPublicKey from it. Note: This method
     * assumes that PEM file contains PKCS#8 encoded Key format please check the format.
     *
     * @param pemFile InputStream of PEM file containing RSA Public Key.
     * @return RSAPublicKey by reading PEM file containing the RSA Private Key.
     * @throws JWTException if unable to read the provided file path or key specification is
     *     incorrect etc.
     */
    public static RSAPublicKey getRSAPublicKeyFromProvidedPEMFilePath(InputStream pemFile)
            throws ServiceApplicationException {
        try {
            String certAndKey = IOUtils.toString(pemFile, StandardCharsets.US_ASCII);
            byte[] keyBytes =
                    parseDERFromPEM(certAndKey, BEGIN_PUBLIC_KEY_TOKEN, END_PUBLIC_KEY_TOKEN);
            X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
            KeyFactory factory = KeyFactory.getInstance("RSA");
            return (RSAPublicKey) factory.generatePublic(spec);
        } catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException e) {
            throw new ServiceApplicationException(ExceptionStatusCodeEnum.SYSTEM_ERROR, e);
        }
    }

    /**
     * Checks if the provided tokens i.e. {@param beginToken} or {@param endToken} are present in
     * the provided {@param contents}.
     *
     * @param contents
     * @param beginToken
     * @param endToken
     * @return true if provided token params are present in contents else false.
     */
    private static boolean containsSection(String contents, String beginToken, String endToken) {
        int idxToken;
        if ((idxToken = contents.indexOf(beginToken)) == -1
                || contents.indexOf(endToken) < idxToken) {
            return false;
        }
        return true;
    }

    /**
     * Converts PEM to DER format i.e. removes the Begin and End tokens and decode the base64
     * encoded certificate.
     *
     * @param pem
     * @param beginDelimiter
     * @param endDelimiter
     * @return DER format Key
     */
    private static byte[] parseDERFromPEM(String pem, String beginDelimiter, String endDelimiter) {
        if (!containsSection(pem, beginDelimiter, endDelimiter)) {
            return new byte[0];
        }
        String[] tokens = pem.split(beginDelimiter);
        tokens = tokens[1].split(endDelimiter);
        return Base64.getMimeDecoder().decode(tokens[0]);
    }
}
